We now introduce Commutative/Non-commutative (CNC) logic in the form
of a term assignment.  One should view this logic as composed of two
logics; one sitting to the left of the other.  On the left, there is
intuitionistic linear logic, denoted by $\cat{C}$, and on the right is
the Lambek calculus denoted by $\cat{L}$.  Then we connect these two
systems by a pair of monoidal adjoint functors $\cat{C} : \func{F}
\dashv \func{G} : \cat{L}$.  Keeping this intuition in mind we now
define the syntax for CNC logic.
\begin{definition}
  \label{def:Lambek-syntax}
  The following grammar describes the syntax of CNC logic:
  \begin{center}\vspace{-5px}
    \begin{math}
      \begin{array}{lll}        
        \text{($\cat{C}$-Types)} & [[W]],[[X]],[[Y]],[[Z]] ::= [[UnitT]] \mid [[X (*) Y]] \mid [[X -o Y]] \mid [[Gf A]]\\
        \text{($\cat{L}$-Types)} & [[A]],[[B]],[[C]],[[DT]] ::= [[UnitS]] \mid [[A (>) B]] \mid [[A -> B]] \mid [[B <- A]] \mid [[F X]]\\        
        \text{($\cat{C}$-Terms)} & [[t]] ::= [[x]] \mid [[trivT]] \mid [[t1 (*) t2]] \mid [[let t1 : X be q in t2]] \mid [[\x:X.t]] \mid [[t1 t2]] \mid [[ex t1 , t2 with x1 , x2 in t3]] \mid [[Gf s]]\\
        \text{($\cat{L}$-Terms)} & [[s]] ::= [[x]] \mid [[trivS]] \mid [[s1 (>) s2]] \mid [[let s1 : A be p in s2]] \mid [[let t : X be q in s]] \mid [[\l x : A.s]] \mid [[\r x : A . s]] \\
        & \,\,\,\,\,\,\,\,\,\mid [[appl s1 s2]] \mid [[appr s1 s2]] \mid [[F t]]\\        
        \text{($\cat{C}$-Patterns)} & [[q]] ::= [[trivTp]] \mid [[x (*) y]] \mid [[Gf q]]\\
        \text{($\cat{L}$-Patterns)} & [[p]] ::= [[trivSp]] \mid [[x (>) y]] \mid [[F p]]\\        
        \text{($\cat{C}$-Contexts)} & [[I]],[[P]] ::= [[.]] \mid [[x : X]] \mid [[I,P]]\\
        \text{($\cat{L}$-Contexts)} & [[G]],[[D]] ::= [[.]] \mid [[x : A]] \mid [[x : X]] \mid [[G;D]]\\        
        \text{($\cat{C}$-Typing Judgment)} & [[I |-c t : X]]\\
        \text{($\cat{L}$-Typing Judgment)} & [[G |-l s : A]]\\
      \end{array}
    \end{math}
  \end{center}
\end{definition}

The syntax for $\cat{C}$-types are the standard types for
intuitionistic linear logic.  We have a unit $[[UnitT]]$, tensor
product $[[X (*) Y]]$, and linear implication $[[X -o Y]]$, but just
as in LNL logic we also have a type $[[Gf A]]$ where $[[A]]$ is an
$\cat{L}$-type; that is, a type from the non-commutative side
corresponding to the right-adjoint functor between $\cat{L}$ and
$\cat{C}$. This functor can be used to import types and terms from the
non-commutative side into the commutative side.  Now $\cat{C}$-typing
judgments are denoted by $[[P |-c t : X]]$ where $[[P]]$ is a sequence
of pairs of variables and their types, denoted by $[[x : X]]$, $[[t]]$
is a $\cat{C}$-term, and $[[X]]$ is a $\cat{C}$-type.  The
$\cat{C}$-terms are all standard, but $[[Gf s]]$ corresponds to the
morphism part of the right-adjoint of the adjunction between both
logics, and $[[ex t1 , t2 with x1 , x2 in t3]]$ is the introduction
form for the structural rule exchange.

The non-commutative side is a bit more interesting than the
commutative side just introduced.  The $\cat{L}$-typing judgment has
the form $[[G |-l s : A]]$ where $[[G]]$ is now a $\cat{L}$-context,
denoted by $[[G]]$ or $[[D]]$. These contexts are ordered sequences of
pairs of free variables with their types from \emph{both} sides
denoted by $[[x : B]]$ and $[[x : X]]$ respectively. Finally, the term
$[[s]]$ is a $\cat{L}$-term, and $[[A]]$ is a $\cat{L}$-type.  Given
two typing contexts $[[G]]$ and $[[D]]$ we denote their concatenation
by $[[G;D]]$; we use a semicolon here to emphasize the fact that the
contexts are ordered.

The context consisting of hypotheses from both sides goes back to
Benton~\cite{Benton:1994} and is a property unique to adjoint logics
such as Benton's LNL logic and CNC logic.  This is also a very useful
property because it allows one to make use of both sides within the
Lambek calculus without the need to annotate every formula with a
modality.

The reader familiar with LNL logic will notice that our typing
judgment, $[[G |-l s : A]]$, differs from Benton's. His is of the form
$\Gamma;\Delta \vdash t : A$, where $\Gamma$ contains non-linear
formulas, and $\Delta$ contains linear formulas.  Just as Benton
remarks, the splitting of his contexts was a presentational device.
One should view his contexts as merged, and hence, linear formulas
were fully mixed with non-linear formulas.  Now why did we not use
this presentational device?  Because, when contexts from LNL logic
become out of order Benton could use the exchange rule to put them
back in order again, but we no longer have general exchange. Thus, we
are not able to keep the context organized in this way.

The syntax for $\cat{L}$-types are of the typical form for the Lambek
Calculus.  We have an unit type $[[UnitS]]$, a non-commutative tensor
product $[[A (>) B]]$, right implication $[[A -> B]]$, and left
implication $[[B <- A]]$.  $\cat{L}$-terms correspond to introduction
and elimination forms for each of the previous types.  For example,
$[[s1 (>) s2]]$ introduces a tensor, and $[[let s1 : A (>) B be x (>)
    y in s2]]$ eliminates a tensor.

The typing rules for CNC logic can be found in
Figure~\ref{fig:CNC-typing-rules}.
\begin{figure}
  \footnotesize
  \begin{tabular}{|c|}
    \hline\\
      \begin{mathpar}
      \NDdruleTXXid{} \and
      \NDdruleTXXunitI{} \and
      \NDdruleTXXunitE{} \and
      \NDdruleTXXtenI{} \and
      \NDdruleTXXtenE{} \and
      \NDdruleTXXimpI{} \and
      \NDdruleTXXimpE{} \and
      \NDdruleTXXGI{} \and
      \NDdruleTXXbeta{} \and
      \NDdruleTXXcut{}      
      \end{mathpar}
      \\
      \\
      \hline
      \\[5px]
    \begin{mathpar}
      \NDdruleSXXid{} \and
      \NDdruleSXXunitI{} \and
      \NDdruleSXXunitETwo{} \and
      \NDdruleSXXunitEOne{} \and
      \NDdruleSXXtenI{} \and
      \NDdruleSXXtenETwo{} \and
      \NDdruleSXXtenEOne{} \and
      \NDdruleSXXimprI{} \and
      \NDdruleSXXimprE{} \and
      \NDdruleSXXimplI{} \and
      \NDdruleSXXimplE{} \and
      \NDdruleSXXFI{} \and
      \NDdruleSXXFE{} \and
      \NDdruleSXXGE{} \and
      \NDdruleSXXbeta{} \and
      \NDdruleSXXcutTwo{} \and
      \NDdruleSXXcutOne{}
    \end{mathpar}\\\\
    \hline
  \end{tabular}  
  \caption{Typing Rules for CNC Logic}
  \label{fig:CNC-typing-rules}
\end{figure}
We split the figure in two: the top of the figure are the rules of
intuitionistic linear logic whose judgment is the $\mathcal{C}$-typing
judgment denoted by $[[P |-c t : X]]$, and the bottom of the figure
are the rules for the mixed commutative/non-commutative Lambek
calculus whose judgment is the $\mathcal{L}$-judgment denoted by $[[G
    |-l s : A]]$, but the two halves are connected via the functor
rules $\NDdruleTXXGIName{}$, $\NDdruleSXXGEName{}$,
$\NDdruleSXXFIName{}$, and $\NDdruleSXXFEName{}$.  Just as in LNL
logic, the fact that the context $[[G]]$ on the $\mathcal{L}$ side of
the logic is mixed results in this side having additional elimination
rules, because the type being eliminated is constructed on the
$\mathcal{C}$ side of the logic; for example, the rules
$\NDdruleSXXunitEOneName{}$, $\NDdruleSXXtenEOneName{}$, and
$\NDdruleSXXcutOneName{}$ are additional mixed rules.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: main.tex
%%% End:

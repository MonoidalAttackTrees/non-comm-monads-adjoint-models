% Input variables.
metavar vars ,  n , a, x , y, z , w , m , o ::=  
indexvar ivar, i , k , j , l ::=
metavar const, b ::= 

grammar


% Lambek category:
A, B, C :: 'lform_' ::=
  | Base    ::   :: Base          
  {{tex \mathsf{B} }}
  | I       ::   :: I
  {{tex \mathrm{I} }}
  | A (x) B ::   :: Lambek
  | A -o B  ::   :: RFun          
  | ( A )   :: M :: Parens 
  | h( A )  :: M :: HiddenParens 
  {{ tex [[A]] }}
  | F X     ::   :: LeftAdj
  {{tex \mathsf{F}[[X]] }}

% Symmetric monoidal closed category:
X, Y, Z :: 'sform_' ::=
  | Base    ::   :: Base          
  {{tex \mathsf{B} }}
  | 1       ::   :: 1
  {{tex \mathsf{1} }}
  | X (t) Y   ::   :: Tensor        
  | X -> Y  ::   :: Fun          
  | ( X )   :: M :: Parens 
  | h( X )  :: M :: HiddenParens 
  {{ tex [[X]] }}
  | Gf A     ::   :: RightAdj
  {{tex \mathsf{G}[[A]] }}

T :: 'type_' ::=
  | A :: :: LType
  | X :: :: SType

p :: 'pattern_' ::=
  | - :: :: hole
  {{tex \star }}
  | x :: :: var
  | () :: :: trivT
  {{tex \mathsf{trivT} }}
  | * :: :: trivS
  {{tex \ast }}
  | p (x) p' :: :: ten
  | p (t) p'   :: :: sum
  | F p :: :: LeftAdj
  {{tex \mathsf{F}\,[[p]] }}
  | Gf p     ::   :: RightAdj
  {{tex \mathsf{G}\,[[p]] }}

s :: 'term_' ::=
  | x :: :: Var
  | b :: :: Const
  | * :: :: UnitS
  {{tex \ast }}
  | let s1 : T be p in s2 :: :: let1
  {{tex \mathsf{let}\,[[s1]] : [[T]]\,\mathsf{be}\,[[p]]\,\mathsf{in}\,[[s2]] }}
  | let t : T be p in s :: :: let2
  {{tex \mathsf{let}\,[[t]] : [[T]]\,\mathsf{be}\,[[p]]\,\mathsf{in}\,[[s]] }}
  | s1 (x) s2 :: :: Tensor
  | \ x : A . s :: :: LFun
  {{tex \lambda [[x]] : [[A]].[[s]] }}
  | app s1 s2   :: :: App
  {{tex \mathsf{app}\,[[s1]]\,[[s2]] }}
  | derelict t :: :: Derelict
  {{tex \mathsf{derelict}\,[[t]] }}
  | [ s1 / x ] s2 :: M :: Subst
  | [ t / x ] s   :: M :: Subst2
  | ( s )         :: S :: parens
  | h( s )        :: M :: hparen
  {{tex [[s]] }}
  | F t           ::   :: LeftAdj
  {{tex \mathsf{F}[[t]] }}

t :: 'sterm_' ::=
  | x  :: :: Var
  | b  :: :: Const
  | () :: :: UnitT
  | let t1 : X be p in t2 :: :: let
  {{tex \mathsf{let}\,[[t1]] : [[X]]\,\mathsf{be}\,[[p]]\,\mathsf{in}\,[[t2]] }}
  | t1 x t2 :: :: Tensor
  | \ x : X . t :: :: Fun
  {{tex \lambda [[x]] : [[X]].[[t]] }}  
  | app t1 t2   :: :: App
  {{tex \mathsf{app}\,[[t1]]\,[[t2]] }}  
  | ( t1 , t2 )   :: :: Prod
  {{tex \mathsf{(}[[t1]] , [[t2]]\mathsf{)} }}
  | fst ( t )     :: :: Fst
  {{tex \mathsf{fst(}[[t]]\mathsf{)} }}
  | snd ( t )     :: :: Snd
  {{tex \mathsf{snd(}[[t]]\mathsf{)} }}
  | [ t1 / x ] t2 :: M :: Subst
  | ( t )         :: S :: parens
  | h( t )        :: M :: hparen
  | Gf s           ::   :: RightAdj
  {{tex \mathsf{G}[[s]] }}

I {{tex \Phi}}, P {{tex \Psi}} :: 'CCtx_' ::=
  | .       ::   :: Empty
  {{tex \cdot }}
  | I1 , I2 ::   :: Ext
  | x : X   ::   :: ElC
  | ( I )   :: S :: Paren

G {{tex \Gamma}}, D {{tex \Delta}} :: 'Ctx_' ::=
  | .       ::   :: Empty
  {{tex \cdot }}
  | x : A   ::   :: El
  | Pi      ::   :: CCtx1
  | Pi ; G   ::   :: CCtx2
  | G1 , G2 ::   :: Ext
  | ( G )   :: S :: Paren

formula :: 'formula_' ::=
  | judgement            ::   :: judgement
  | formula1 && formula2 :: M :: quad
  {{tex [[formula1]] \quad [[formula2]] }}
  | formula1 ... formulai :: M :: vec
  | ( formula )          :: S :: parens
  {{tex [[formula]] }}

terminals :: 'terminals_' ::=
  | 1    :: :: UnitT
  {{tex \mathsf{1} }}
  | I    :: :: UnitS
  {{tex \mathrm{I} }}
  | (x)  :: :: Tensor
  {{tex \otimes }}
  | (t)  :: :: Sum
  {{tex \times }}
  | (e)  :: :: ETensor
  {{tex \circop{e} }}  
  | (w)  :: :: WTensor
  {{tex \circop{w} }}  
  | (c)  :: :: CTensor
  {{tex \circop{c} }}
  | ->   :: :: LFun
  {{tex \rightarrow }}
  | -o   :: :: Limp
  {{tex \multimap }}
  | |-c   :: :: VdashC
  {{tex \vdash_\mathcal{C} }}
  | |-l   :: :: VdashL
  {{tex \vdash_\mathcal{L} }}
  | ~>   :: :: To
  {{tex \leadsto }}
 
defns
  Jtype :: '' ::=

defn
  I |-c t : X :: :: tty :: 'T_'
by 

  ------------------ :: id
  I, x : X |-c x : X

  ------------ :: 1I
  I |-c () : 1

  I |-c t1 : X && I |-c t2 : Y
  ---------------------------- :: prodI
  I |-c (t1 , t2) : X (t) Y

  I |-c t : X (t) Y
  ----------------- :: prodE1
  I |-c fst(t) : X

  I |-c t : X (t) Y
  ----------------- :: prodE2
  I |-c snd(t) : X

  I, x : X |-c t : Y
  -------------------------- :: impI
  I |-c \ x : X . t : X -> Y

  I |-c t1 : X -> Y && I |-c t2 : X
  --------------------------------- :: impE
  I |-c app t1 t2 : Y

  I |-l s : A
  ----------------- :: GI
  I |-c Gf s : Gf A

defn
  G |-l s : A :: :: sty :: 'S_'
by

  ------------------- :: id
  I; x : A |-l x : A

  I; G |-l s1 : A && I; D |-l s2 : B
  ---------------------------------- :: tenI
  I; G, D |-l s1 (x) s2 : A (x) B

  I; G |-l s1 : A (x) B && I; D, x : A, y : B |-l s2 : C
  ------------------------------------------------------ :: tenE
  I; G, D |-l let s1 : A (x) B be x (x) y in s2 : C

  ----------- :: II
  I |-l * : I

  I; G |-l s1 : I && I; D |-l s2 : A
  ------------------------------------- :: IE
  I; G, D |-l let s1 : I be * in s2 : A

  I; G, x : A |-l s : B
  ------------------------------ :: impI
  I; G |-l \ x : A . s : A -o B

  I; G |-l s1 : A -o B && I; D |-l s2 : A
  --------------------------------------- :: impE
  I; G, D |-l app s1 s2 : B

  I |-c t : X
  --------------- :: FI
  I |-l F t : F X

  I; G |-l s1 : F X && I, x : X; D |-l s2 : A
  ------------------------------------------- :: FE
  I; G, D |-l let s1 : F X be F x in s2 : A

  I |-c t : Gf A
  -------------------- :: GE
  I |-l derelict t : A



